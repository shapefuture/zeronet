// Auto-generated by flatc --ts; using FlatBuffers library for actual decode

import * as flatbuffers from 'flatbuffers';

export class DOMSnapshot {
  bb: flatbuffers.ByteBuffer | null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): DOMSnapshot {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsDOMSnapshot(bb: flatbuffers.ByteBuffer) {
    return (new DOMSnapshot()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  url(): string | null {
    const bb = this.bb; if (!bb) return null;
    const offset = bb.__offset(this.bb_pos, 4); if (offset === 0) return null;
    return bb.__string(this.bb_pos + offset);
  }
  html(): string | null {
    const bb = this.bb; if (!bb) return null;
    const offset = bb.__offset(this.bb_pos, 6); if (offset === 0) return null;
    return bb.__string(this.bb_pos + offset);
  }
  timestamp(): number {
    const bb = this.bb; if (!bb) return 0;
    const offset = bb.__offset(this.bb_pos, 8); if (offset === 0) return 0;
    return bb.readUint64(this.bb_pos + offset);
  }
  metadata(): string | null {
    const bb = this.bb; if (!bb) return null;
    const offset = bb.__offset(this.bb_pos, 10); if (offset === 0) return null;
    return bb.__string(this.bb_pos + offset);
  }
}